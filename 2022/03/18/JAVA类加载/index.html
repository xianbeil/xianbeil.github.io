<!DOCTYPE html>
<html lang="zh-CN">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="Xi4nb3i" />
  <meta name="description" content="" />
  
  
  <title>
    
      JAVA类加载 
      
      
    
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.svg">
    <link rel="icon" href="/images/favicon.svg">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Montserrat|Roboto:400,400italic,600|Roboto+Mono" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">


  

  
    
<link rel="stylesheet" href="/css/post.css">

  

  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  
<script src="/js/fancybox.js"></script>


<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Xi4nb3i's blog" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <a href="/">Xi4nb3i</a>
</div>


      <p class="links">
  
    <a title="archives" target="" href="/archives/">
      <i class="iconfont icon-bookmark"></i>
    </a>
  
    <a title="github" target="_blank" href="https://github.com/xianbeil">
      <i class="iconfont icon-github"></i>
    </a>
  
    <a title="twitter" target="_blank" href="https://twitter.com/aeqaq0">
      <i class="iconfont icon-twitter"></i>
    </a>
  
</p>


      <div class="main">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->

<!-- LaTex Display -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>

<div class="post">
  <h3 class="date">
    Mar 18, 2022
  </h3>
  <h1>
    JAVA类加载
  </h1>
  <div class="content markdown-body">
    <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>从一下几个方面了解JAVA中，类加载的原理</p>
<ol>
<li>java代码执行过程</li>
<li>类的加载过程</li>
<li>类加载器</li>
<li>类加载机制</li>
<li>自定义一个自己的类加载器</li>
</ol>
<h1 id="java代码执行流程"><a href="#java代码执行流程" class="headerlink" title="java代码执行流程"></a>java代码执行流程</h1><p><img src="https://b3logfile.com/siyuan/1642857713240/assets/image-20220318204423-paolccp.png" alt="image.png"><img src="https://b3logfile.com/siyuan/1642857713240/assets/image-20220318204536-oxlseqj.png" alt="image.png"></p>
<p>当 .java 源码被 javac.exe 编译器编译成 .class 字节码文件后，接下来的工作就交给JVM处理。JVM首先通过类加载器(ClassLoader)，将class文件和相关Java API加载装入JVM，以供JVM后续处理。</p>
<h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><p>类的生命周期包括：加载、链接、初始化、使用、卸载</p>
<p>其中前三个属于类的<u>加载过程</u></p>
<h2 id="加载-loading"><a href="#加载-loading" class="headerlink" title="加载-loading"></a>加载-loading</h2><p>把<code>.class</code>文件加载到JVM里的过程</p>
<ul>
<li>通过类的全限定名来获取定义此类的二进制字节流</li>
<li>将此二进制字节流所代表的静态存储结构转化成方法区的运行时数据结构</li>
<li>在内存中生成代表此类的java.lang.Class对象,作为该类访问入口.</li>
</ul>
<h2 id="链接-linking"><a href="#链接-linking" class="headerlink" title="链接-linking"></a>链接-linking</h2><p>链接分为三步</p>
<ul>
<li><p>验证:验证的目的是确保class文件的字节流中信息符合虚拟机的要求，不会危害虚拟机安全，使得虚拟机免受恶意代码的攻击，这一步至关重要。</p>
<blockquote>
<p>文件格式验证<br>源数据验证<br>字节码验证<br>符号引用验证  </p>
</blockquote>
</li>
<li><p>准备:准备阶段的工作就是为类的静态变量<strong>分配内存</strong>并设为jvm默认的<strong>初值</strong>，对于非静态的变量，则不会为它们分配内存。静态变量的初值为jvm默认的初值，而不是我们在程序中设定的初值。(仅包含类变量,不包含实例变量).</p>
</li>
<li><p>解析:虚拟机将常量池中的符号引用替换为直接引用，解析动作主要针对类或接口，字段，类方法，方法类型等等。</p>
</li>
</ul>
<h2 id="初始化-initialization"><a href="#初始化-initialization" class="headerlink" title="初始化-initialization"></a>初始化-initialization</h2><p>在该阶段，才真正意义上的开始执行类中定义的java程序代码，该阶段会执行类构造器。</p>
<blockquote>
<p>暂讨论关于类生命周期的三种，之后在学习内存的时候细嗦</p>
</blockquote>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="ClassLoader的作用"><a href="#ClassLoader的作用" class="headerlink" title="ClassLoader的作用"></a>ClassLoader的作用</h2><blockquote>
<p><strong>ClassLoader用于将class文件加载到JVM中。</strong></p>
</blockquote>
<p>另外一个作用是确认每个类应该由哪个类加载器加载。<br>第二个作用也用于判断JVM运行时的两个类是否相等，影响的判断方法有equals()、isAssignableFrom()、isInstance()以及instanceof关键字。</p>
<h2 id="何时触发类加载"><a href="#何时触发类加载" class="headerlink" title="何时触发类加载"></a>何时触发类加载</h2><p>类加载的触发可以分为隐式加载和显示加载。</p>
<h3 id="隐式加载"><a href="#隐式加载" class="headerlink" title="隐式加载"></a>隐式加载</h3><p>隐式加载包括以下几种情况：</p>
<ul>
<li>遇到new、getstatic、putstatic、invokestatic这4条字节码指令时</li>
<li>对类进行反射调用时</li>
<li>当初始化一个类时，如果其父类还没有初始化，优先加载其父类并初始化</li>
<li>虚拟机启动时，需指定一个包含main函数的主类，优先加载并初始化这个主类</li>
</ul>
<h3 id="显式加载"><a href="#显式加载" class="headerlink" title="显式加载"></a>显式加载</h3><p>显示加载包含以下几种情况：</p>
<ul>
<li>通过ClassLoader的loadClass方法</li>
<li>通过Class.forName（反射获取Class）</li>
<li>通过ClassLoader的findClass方法</li>
</ul>
<h2 id="ClassLoader分类"><a href="#ClassLoader分类" class="headerlink" title="ClassLoader分类"></a>ClassLoader分类</h2><p><img src="https://b3logfile.com/siyuan/1642857713240/assets/image-20220318210756-8jnb18t.png" alt="image.png"></p>
<p>从上到下认识他们</p>
<h3 id="启动类-x2F-引导类：Bootstrap-ClassLoader"><a href="#启动类-x2F-引导类：Bootstrap-ClassLoader" class="headerlink" title="启动类&#x2F;引导类：Bootstrap ClassLoader"></a>启动类&#x2F;引导类：Bootstrap ClassLoader</h3><p>这个类加载器使用C&#x2F;C++语言实现的，嵌套在JVM内部，java程序无法直接操作这个类。它用来加载<strong>Java核心类库</strong>，如：<code>JAVA_HOME/jre/lib/rt.jar</code>、<code>resources.jar</code>、<code>sun.boot.class.path</code>路径下的包，用于提供<strong>jvm运行所需的包</strong>。</p>
<p>并不是继承自java.lang.ClassLoader，它没有父类加载器</p>
<p>它加载<code>扩展类加载器</code>和<code>应用程序类加载器</code>，并成为他们的<strong>父类加载器</strong></p>
<p>出于安全考虑，启动类只加载包名为：java、javax、sun开头的类</p>
<h3 id="扩展类加载器：Extension-ClassLoader"><a href="#扩展类加载器：Extension-ClassLoader" class="headerlink" title="扩展类加载器：Extension ClassLoader"></a>扩展类加载器：Extension ClassLoader</h3><p>Java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现，我们可以用Java程序操作这个加载器派生继承自java.lang.ClassLoader，父类加载器为<code>启动类加载器</code></p>
<p>从系统属性：<code>java.ext.dirs</code>目录中加载类库，或者从JDK安装目录：<code>jre/lib/ext</code>目录下加载类库。我们就可以将我们自己的包放在以上目录下，就会自动加载进来了。</p>
<h3 id="应用程序类加载器：Application-Classloader"><a href="#应用程序类加载器：Application-Classloader" class="headerlink" title="应用程序类加载器：Application Classloader"></a>应用程序类加载器：Application Classloader</h3><p>程序默认的类加载器，我们编写的类就是由他来加载。</p>
<p>Java语言编写，由sun.misc.Launcher$AppClassLoader实现。<br>派生继承自<code>java.lang.ClassLoader</code>，父类加载器为ExtClassloader</p>
<p>它负责加载环境变量classpath或者系统属性java.class.path指定路径下的类库</p>
<p>我们可以通过<code>ClassLoader#getSystemClassLoader()</code>获取并操作这个加载器</p>
<h3 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h3><p>为了实现自己的功能，比如加强安全传输，我们可以自己编写加载器。</p>
<p>继承<code>java.lang.ClassLoader</code>类，重写findClass()方法如果没有太复杂的需求，可以直接继承<code>URLClassLoader</code>类，重写<code>loadClass</code>方法，具体可参考<code>AppClassLoader</code>和<code>ExtClassLoader</code>。</p>
<h2 id="获取ClassLoader"><a href="#获取ClassLoader" class="headerlink" title="获取ClassLoader"></a>获取ClassLoader</h2><p>除了启动类加载器，其他加载器都是继承自<code>java.lang.ClassLoader</code>这个抽象类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：获取当前类的 ClassLoader</span></span><br><span class="line">clazz.getClassLoader()</span><br><span class="line"><span class="comment">// 方式二：获取当前线程上下文的 ClassLoader</span></span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br><span class="line"><span class="comment">// 方式三：获取系统的 ClassLoader</span></span><br><span class="line">ClassLoader.getSystemClassLoader()</span><br><span class="line"><span class="comment">// 方式四：获取调用者的 ClassLoader</span></span><br><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></table></figure>

<h1 id="类加载机制-双亲委派"><a href="#类加载机制-双亲委派" class="headerlink" title="类加载机制-双亲委派"></a>类加载机制-双亲委派</h1><p>jvm对class文件采用的是按需加载的方式，当需要使用该类时，jvm才会将它的class文件加载到内存中产生class对象。</p>
<p>在加载类的时候，是采用的<code>双亲委派机制</code>，即把请求交给父类处理的一种<code>任务委派模式。</code></p>
<p>这也被叫做<code>双亲委派模型</code>，在jdk1.2之后引入</p>
<blockquote>
<p>其中，两个用户自定义类加载器的父加载器是AppClassLoader，AppClassLoader的父加载器是ExtClassLoader，ExtClassLoader是没有父类加载器的，在代码中，ExtClassLoader的父类加载器为null。BootstrapClassLoader也并没有子类，因为他完全由JVM实现。</p>
</blockquote>
<p><img src="https://b3logfile.com/siyuan/1642857713240/assets/image-20220318212050-guhqqwe.png" alt="image.png"></p>
<h2 id="工作逻辑"><a href="#工作逻辑" class="headerlink" title="工作逻辑"></a>工作逻辑</h2><p>（1）如果一个<code>类加载器</code>接收到了<code>类加载</code>的请求，它自己不会先去加载，会把这个请求委托给<code>父类加载器</code>去执行。</p>
<p>（2）如果父类还存在父类加载器，则继续向上委托，一直委托到<code>启动类加载器：Bootstrap ClassLoader</code></p>
<p>（3）如果父类加载器可以完成加载任务，就返回成功结果，如果父类加载失败，就由子类自己去尝试加载，如果子类加载失败就会抛出<code>ClassNotFoundException</code>异常，这就是<code>双亲委派模式</code></p>
<h2 id="使用目的"><a href="#使用目的" class="headerlink" title="使用目的"></a>使用目的</h2><p>双亲委派模型能够保证类在内存中的<strong>唯一性</strong>，能够保证系统级别类的安全，因为当启动类ClassLoader加载过了之后，子ClassLoader便不会再加载：</p>
<p>1、防止重复加载同一个<code>.class</code>。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。<br>2、保证核心<code>.class</code>不能被篡改。通过委托方式，不会去篡改核心<code>.clas</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</p>
<h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><p>loadClass方法如下，代码中做了注释解析</p>
<p>双亲委派模型实现的核心就是这个loadClass方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">// 先查看这个类是否已经被自己加载了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果有父类加载器，先委派给父类加载器来加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果父类加载器为null，说明ExtClassLoader也没有找到目标类，则调用BootstrapClassLoader来查找</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果都没有找到，调用findClass方法，尝试自己加载这个类</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><p>我们可以实现自己的类加载器，加载<strong>指定路径</strong>下的class文件</p>
<ul>
<li>通过loadClass在指定的路径下查找文件。</li>
<li>通过findClass方法解析class字节流，并实例化class对象。</li>
</ul>
<p>编写一个自己的ClassLoader</p>
<blockquote>
<p>defineClass：将字节码变成内存中的class</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xianbei.test3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestClassLoader</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] classBytes = getData(name);</span><br><span class="line">            <span class="comment">//defineClass来生成class实例</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name,classBytes,<span class="number">0</span>,classBytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法读取目标class文件的字节码并返回</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getData(String className) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> classPath+ File.separator + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//读取字节</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2048</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((num = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                stream.write(buffer, <span class="number">0</span> ,num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stream.toByteArray();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后我们尝试加载自己电脑上指定路径的class文件：</p>
<p>这是我要加载的class文件，之前用JAVAssist控制字节码编写的恶意类</p>
<blockquote>
<p>这里有个静态块，就是最后的static</p>
<p>在实例化的时候会被自动加载</p>
<p>关于JAVAssist不在此多做赘述</p>
</blockquote>
<p><img src="https://b3logfile.com/siyuan/1642857713240/assets/image-20220318233518-9dfmw13.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCLDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">TestClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestClassLoader</span>(<span class="string">&quot;C:\\Users\\Liyc\\IdeaProjects\\JavassistTest\\out&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; newStudent = myClassLoader.loadClass(<span class="string">&quot;NewStudent&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; c = newStudent.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> c.newInstance(<span class="string">&quot;Xianbei&quot;</span>,<span class="number">19</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://b3logfile.com/siyuan/1642857713240/assets/image-20220318233657-sw8m038.png" alt="image.png"></p>
<p>成功弹出计算机，也就是成功加载了指定路径下的class文件并且用反射将其实例化了。</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>贴几张好文和好图</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/goloving/p/14438785.html">https://www.cnblogs.com/goloving/p/14438785.html</a>讲双亲委派的</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fe8a01b0c3b7">https://www.jianshu.com/p/fe8a01b0c3b7</a>讲java代码运行机制的</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/67991761">https://zhuanlan.zhihu.com/p/67991761</a>讲类加载的</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xrq730/p/4847337.html">https://www.cnblogs.com/xrq730/p/4847337.html</a>很多种类加载器的写法</p>
<p><img src="https://b3logfile.com/siyuan/1642857713240/assets/image-20220318213310-uz3iggg.png" alt="image.png"></p>

  </div>
  
    
      <a id="older" class="blog-nav" href="/2022/03/17/cc2study/">OLDER&nbsp;&gt;</a>
      
        
          <a id="newer" class="blog-nav" href="/2022/03/20/cc3study/">&lt;&nbsp;NEWER</a>
          
            
</div>
        <div class="footer">
  
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/leedom92/hexo-theme-leedom">Copyright © Leedom 2021</a>
        
    </div>
  
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/leedom92/hexo-theme-leedom">Theme by Leedom | Powered by Hexo</a>
        
    </div>
  
</div>

      </div>

      <div class="back-to-top hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



      


    </div>
  </body>
</html>
